;;; By John Wiseman (jjwiseman@yahoo.com);;; Copyright 1998, 2005;;;;;; Licensed under the MIT License (see the accompanying LICENSE.TXT;;; file for details).;;;;;; The code for drawing the faces is based on the code in the book;;; Computers, Pattern, Chaos and Beauty by Clifford Pickover.;;;;;; Requires MCL(require :quickdraw)(defun eccentricities (p)  (cond ((> p 5)         (values (* (- p 5) 2) 0))        ((< p 5)         (values 0 (* (abs (- p 5)) 2)))        (T (values 0 0))))(defun deg->rad (d)  (* d #.(/ pi 180)))(defun smove-to (view x y)  (let ((scale (/ (point-h (view-size view)) 100)))    (move-to view             (round (* x scale))             (- (point-v (view-size view))                (round (* y scale))))))(defun sline-to (view x y)  (let ((scale (/ (point-h (view-size view)) 100)))    (line-to view             (round (* x scale))             (- (point-v (view-size view)) (round (* y scale))))))(defun scircle (view x y r)  (let* ((scale (/ (point-h (view-size view)) 100))         (sx (round (* x scale)))         (sy (- (point-v (view-size view)) (round (* y scale))))         (sr (round (* r scale))))    (paint-oval view (- sx sr) (- sy sr) (+ sx sr) (+ sy sr))))(defun soval (view x y h v)  (let* ((scale (/ (point-h (view-size view)) 100))         (sx (round (* x scale)))         (sy (- (point-v (view-size view)) (round (* y scale))))         (sh (round (* h scale)))         (sv (round (* v scale))))    (frame-oval view (- sx sh) (- sy sv) (+ sx sh) (+ sy sv))))(defun draw-face (view p1 p2 p3 p4 p5 p6 p7 p8 p9 p10)  (flet ((head ()           (multiple-value-bind (eccen-x eccen-y)	       (eccentricities p1)             (let ((radius 30))               (soval view 50 50 (+ radius eccen-x) (+ radius eccen-y))               )))         (eye ()           (multiple-value-bind (eccen-x eccen-y)	       (eccentricities p2)             (let ((radius 5)                   (eye-spacing (- p7 5))                   (eye-size (/ (- p8 5) 2)))               (soval view (+ 40 (- eye-spacing)) 60                      (+ radius eye-size eccen-x)                      (+ radius eye-size eccen-y))               (soval view (+ 60 eye-spacing) 60                      (+ radius eye-size eccen-x)                      (+ radius eye-size eccen-y)))))         (pupil ()           (let ((pupil-size (max (* p3 0.2) 0.2)))             (scircle view (- 40 (- p7 5)) 60 pupil-size)             (scircle view (+ 60 (- p7 5)) 60 pupil-size)))         (eyebrow ()           (let ((y1 (+ (- p4 5) 70))                 (y2 (- 70 (- p4 5))))             (smove-to view 35 y1)             (sline-to view 45 y2)             (smove-to view 55 y2)             (sline-to view 65 y1)))         (nose ()           (let ((y (+ 45 (/ (- p5 5) 2))))             (smove-to view 50 55)             (sline-to view 46 y)             (sline-to view 54 y)             (sline-to view 50 55)))         (mouth ()           (let* ((mouth-size (- p9 5))                  (x1 (- 40 mouth-size))                  (y1 35)                  (x2 (+ 60 mouth-size))                  (y2 35)                  (x3 (+ (/ (- x2 x1) 2) x1))                  (y3 (+ (- p6 5) 35)))             (flet ((lip (y3)                      (smove-to view x1 y1)                      (let* ((denom (+ (* (expt x1 2) (- x2 x3))                                       (* x1 (- (expt x3 2) (expt x2 2)))                                       (* (expt x2 2) x3)                                       (- (* (expt x3 2) x2))))                             (a (/ (+ (* y1 (- x2 x3))                                      (* x1 (- y3 y2))                                      (* y2 x3)                                      (- (* y3 x2)))                                   denom))                             (bb (/ (+ (* (expt x1 2) (- y2 y3))                                       (* y1 (- (expt x3 2) (expt x2 2)))                                       (* (expt x2 2) y3)                                       (- (* (expt x3 2) y2)))                                    denom))                             (c (/ (+ (* (expt x1 2) (- (* x2 y3) (* x3 y2)))                                      (* x1 (- (* (expt x3 2) y2)                                               (* (expt x2 2) y3)))                                      (* y1 (- (* (expt x2 2) x3)                                               (* (expt x3 2) x2))))                                   denom)))                        (format T "~&~S, ~S, ~S, ~S, ~S, ~S" x1 y2 x2 y2 x3 y3)                        (print denom)                        (do ((i x1 (+ i 1)))                            ((> i x2))                          (sline-to view                                    i                                    (+ (* a (expt i 2))                                       (* bb i)                                       c))))))               (lip y3)               (lip (+ y3 (/ p10 2)))))))    (head)    (eye)    (pupil)    (eyebrow)    (nose)    (mouth)))(defun vector-interp (v1 v2 r)  (let ((v (copy-seq v1)))    (dotimes (i 10)      (setf (elt v i) (+ (elt v1 i) (* r (- (elt v2 i) (elt v1 i))))))    v))(defun vector-dist (v1 v2)  (flet ((sqr (x) (* x x)))    (let ((sum 0.0))      (dotimes (i 10)        (incf sum (sqr (- (elt v2 i) (elt v1 i)))))      (sqrt sum))))(defclass chernoff-window (window)  ((face-view :accessor face-view :initform nil)   (knobs-view :accessor knobs-view :initform nil)))(defmethod initialize-instance :around ((self chernoff-window) &key)  (call-next-method)  (let* ((face-view (make-instance 'chernoff-view))         (knob-views (mapcar #'(lambda (name)                                 (make-instance 'knob-view						:name name						:chernoff-view face-view))                             '("p1" "p2" "p3" "p4" "p5" "p6" "p7" "p8" "p9" "p10")))         (knobs-view (make-instance 'view)))    (setf (knobs face-view) self)    (apply #'add-subviews knobs-view knob-views)    (add-subviews self face-view knobs-view)    (setf (face-view self) face-view)    (setf (knobs-view self) knobs-view)    (resize self)))(defmethod resize ((self chernoff-window))  (let ((width (point-h (view-size self)))        (height (point-v (view-size self))))    (set-view-size (face-view self) (round (* width .75)) height)    (set-view-size (knobs-view self) (- width (round (* width .75))) height)    (set-view-position (knobs-view self) (round (* width .75)) 0)    (do ((knobs (subviews (knobs-view self)) (cdr knobs))         (v 0 (+ v prev-height))         (prev-height (point-v (view-size (car (subviews (knobs-view self))))) (point-v (view-size (car knobs)))))        ((endp knobs))      (set-view-position (car knobs) 0 v)      (resize (car knobs)))    (invalidate-view (face-view self) T)))(defmethod set-view-size :around ((self chernoff-window) h &optional v)  (declare (ignore h v))  (call-next-method)  (resize self))(defmethod knob-parms ((self chernoff-window))  (if (and (knobs-view self) (subviews (knobs-view self)))    (mapcar #'knob-value (subviews (knobs-view self)))    (list 5 5 5 5 5 5 5 5 5 5)))    (defclass chernoff-view (simple-view)  ((knobs :accessor knobs :initarg :knobs :initform nil)))(defmethod view-draw-contents ((self chernoff-view))  (apply #'draw-face self (knob-parms (knobs self))))(defclass knob-view (view)  ((name :accessor name :initform nil :initarg :name)   (chernoff-view :accessor chernoff-view :initform nil :initarg :chernoff-view)   (label :accessor label :initform nil)   (scrollbar :accessor scrollbar :initform nil)))(defmethod initialize-instance :around ((self knob-view) &key)  (call-next-method)  (let ((label (make-instance 'static-text-dialog-item                 :dialog-item-text (name self)                 :text-justification :center))        (scrollbar (make-instance 'scroll-bar-dialog-item                     :direction :horizontal                     :min 0                     :max 10                     :setting 5                     :track-thumb-p T                     :scrollee self)))    (setf (label self) label)    (setf (scrollbar self) scrollbar)    (add-subviews self label scrollbar)))(defmethod knob-value ((self knob-view))  (scroll-bar-setting (scrollbar self)))(defmethod scroll-bar-changed ((self knob-view) scrollbar)  (declare (ignore scrollbar))  (invalidate-view (chernoff-view self) T))(defmethod install-view-in-window :around ((self knob-view) window)  (declare (ignore window))  (call-next-method)  (resize self))(defmethod resize ((self knob-view))  (let ((container-width (point-h (view-size (view-container self))))        (label-size (view-size (label self)))        (scrollbar-size (view-size (scrollbar self))))    (set-view-size self container-width (+ (point-v label-size)                                           (point-v scrollbar-size)                                           10))    (set-view-size (label self) container-width (point-v label-size))    (set-view-size (scrollbar self) container-width (point-v scrollbar-size))    (set-view-position (scrollbar self) 0 (+ (point-v label-size) 10))))      #|(without-interrupts (labels ((x () (+ (random 10) 1))          (rand-v () (vector (x) (x) (x) (x) (x) (x) (x) (x) (x) (x))))   (let ((w (target))         (n 0))     (labels ((transition (prev next)                (let ((frames (round (* (vector-dist next prev) .4))))                  (dotimes (i frames)                    (erase-rect w #@(0 0) (view-size w))                    (apply #'draw-face                           w                           (coerce (vector-interp prev next (/ i frames))                                   'list))                    ;(q3:write-window-pixmap-as-pict w (format nil "Macintosh HD:tmp:face.~5,'0D" n))                    (incf n))))              (next (prev count)                (if (<= count 0)                  prev                  (let ((target (rand-v)))                    (transition prev target)                    (next target (- count 1))))))       (transition (next (vector 5 5 5 5 5 5 5 5 5 5) 20)                   (vector 5 5 5 5 5 5 5 5 5 5))))))|#